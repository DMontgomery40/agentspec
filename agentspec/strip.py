#!/usr/bin/env python3
"""
Agentspec strip utilities: remove agentspec-generated docstrings/YAML safely.
"""

from pathlib import Path
from typing import Tuple


def _detect_agentspec_doc(doc: str) -> Tuple[bool, bool]:
    """
    ---agentspec
    what: |
      Heuristically detects whether a docstring was generated by agentspec as YAML or narrative form.

      Returns a tuple (is_yaml, is_narrative) where:
      - is_yaml: True if the docstring contains a fenced agentspec YAML block ('---agentspec' and '---/agentspec')
      - is_narrative: True if the docstring contains agentspec narrative section headers like
        'WHAT THIS DOES:', 'WHY THIS APPROACH:', 'AGENT INSTRUCTIONS:', or deterministic sections injected by tooling
        such as 'DEPENDENCIES (from code analysis):' or 'CHANGELOG (from git history):'

      The function is conservative: it only flags narrative if at least one strong indicator is present.
    deps:
      calls:
        - any
      imports: []
    why: |
      Target only agentspec-generated content to avoid deleting user-authored docs.
    guardrails:
      - DO NOT broaden heuristics without tests; avoid false positives
      - ALWAYS check for YAML fences first
    changelog:
      - "2025-10-31: Initial implementation"
    ---/agentspec
    """
    if not doc:
        return (False, False)
    # YAML fence check
    if ('---agentspec' in doc) and ('---/agentspec' in doc):
        return (True, False)
    # Narrative markers
    markers = (
        'WHAT THIS DOES:',
        'WHY THIS APPROACH:',
        'AGENT INSTRUCTIONS:',
        'DEPENDENCIES (from code analysis):',
        'CHANGELOG (from git history):',
        'FUNCTION CODE DIFF SUMMARY (LLM-generated):',
    )
    is_narr = any(m in doc for m in markers)
    return (False, is_narr)


def strip_file(filepath: Path, mode: str, dry_run: bool = False) -> None:
    """
    ---agentspec
    what: |
      Removes agentspec-generated content from a single Python file with compile-safety per edit.

      Behavior:
      - Parses file with AST, finds functions with docstrings
      - Detects agentspec YAML vs narrative docstrings using explicit markers
      - Depending on mode ('yaml'|'docstrings'|'all'), deletes matching docstrings
      - Also removes immediate following lines containing "[AGENTSPEC_CONTEXT]" prints
      - For each deletion candidate, writes a temp file and py_compile checks before committing the change

      Inputs:
      - filepath: Path to Python file
      - mode: One of 'yaml', 'docstrings', 'all'
      - dry_run: If True, only prints actions without modifying files

      Outputs:
      - None; prints progress and performs in-place edits when not dry-run
    deps:
      calls:
        - ast.parse
        - ast.walk
        - isinstance
        - ast.get_docstring
        - _detect_agentspec_doc
        - print
        - py_compile.compile
      imports:
        - ast
        - os
        - tempfile
    why: |
      Per-edit compile checks ensure we never leave a file in a broken state. Bottom-to-top processing avoids
      line shift issues when making multiple deletions in a single file.
    guardrails:
      - DO NOT strip non-agentspec docstrings; only remove when explicit markers are found
      - ALWAYS process functions bottom-to-top to avoid line-number invalidation
      - ALWAYS use tmp file + py_compile before writing changes
      - ALWAYS delete adjacent [AGENTSPEC_CONTEXT] print line if present
    changelog:
      - "2025-10-31: Initial implementation"
    ---/agentspec
    """
    print(f"\nüßπ Processing (strip) {filepath}")
    with open(filepath, 'r', encoding='utf-8') as f:
        lines = f.readlines()

    src = ''.join(lines)
    try:
        import ast
        tree = ast.parse(src)
    except SyntaxError as e:
        print(f"  ‚ùå Syntax error in file: {e}")
        return

    # Collect function docstring spans
    targets: list[tuple[int, int, str]] = []  # (start_idx, end_idx_exclusive, func_name)
    import ast
    for node in ast.walk(tree):
        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)) and node.body:
            first_stmt = node.body[0]
            if isinstance(first_stmt, ast.Expr) and (
                (hasattr(ast, 'Constant') and isinstance(first_stmt.value, ast.Constant) and isinstance(first_stmt.value.value, str)) or
                (hasattr(ast, 'Str') and isinstance(first_stmt.value, ast.Str))
            ):
                doc_text = ast.get_docstring(node) or ''
                is_yaml, is_narr = _detect_agentspec_doc(doc_text)
                if mode == 'yaml':
                    should_delete = is_yaml
                elif mode == 'docstrings':
                    should_delete = is_narr
                else:
                    should_delete = is_yaml or is_narr
                if should_delete:
                    start = first_stmt.lineno - 1
                    end = first_stmt.end_lineno
                    if end < len(lines) and '[AGENTSPEC_CONTEXT]' in lines[end]:
                        end += 1
                    targets.append((start, end, node.name))

    if not targets:
        print("  ‚úÖ Nothing to strip in this file")
        return

    targets.sort(key=lambda t: t[0], reverse=True)

    for start_idx, end_idx, func_name in targets:
        print(f"  ‚úÇÔ∏è  Removing agentspec content in function: {func_name} (lines {start_idx+1}-{end_idx})")
        if dry_run:
            continue
        candidate = list(lines)
        del candidate[start_idx:end_idx]
        import tempfile, py_compile, os as _os
        tmp_fd, tmp_path = tempfile.mkstemp(suffix='.py')
        try:
            _os.close(tmp_fd)
            with open(tmp_path, 'w', encoding='utf-8') as tf:
                tf.writelines(candidate)
            py_compile.compile(tmp_path, doraise=True)
        except Exception as e:
            print(f"  ‚ö†Ô∏è  Syntax check failed after stripping {func_name}: {e}. Skipping this edit.")
            try:
                if _os.path.exists(tmp_path):
                    _os.remove(tmp_path)
            except Exception:
                pass
            continue
        finally:
            try:
                if _os.path.exists(tmp_path):
                    _os.remove(tmp_path)
            except Exception:
                pass
        lines = candidate
        with open(filepath, 'w', encoding='utf-8') as f:
            f.writelines(lines)
        print(f"  ‚úÖ Stripped agentspec content from {func_name}")


def run(target: str, mode: str = "all", dry_run: bool = False) -> int:
    """
    ---agentspec
    what: |
      Batch entry point for stripping agentspec content across Python files.

      Accepts file or directory path, collects Python files, and applies strip_file() to each.
      Dry-run prints intended changes without modifying files. Returns exit code 0 on success, 1 on errors.
    deps:
      calls:
        - Path
        - collect_python_files
        - strip_file
        - print
      imports:
        - agentspec.utils.collect_python_files
        - pathlib.Path
    why: |
      Separate module isolates strip logic for modularity and clean code. Keeps generate focused on generation.
    guardrails:
      - DO NOT require any API credentials; this must remain offline-safe
      - ALWAYS handle both file and directory targets
    changelog:
      - "2025-10-31: Initial implementation"
    ---/agentspec
    """
    from agentspec.utils import collect_python_files

    path = Path(target)
    if not path.exists():
        print(f"‚ùå Error: Path does not exist: {target}")
        return 1

    files = [path] if path.is_file() else collect_python_files(path)

    for fp in files:
        try:
            strip_file(fp, mode, dry_run=dry_run)
        except Exception as e:
            print(f"‚ùå Error processing {fp}: {e}")
    print("\n‚úÖ Done!")
    return 0
