#!/usr/bin/env python3
"""
Agentspec strip utilities: remove agentspec-generated docstrings/YAML safely.
"""

from pathlib import Path
from typing import Tuple


def _detect_agentspec_doc(doc: str) -> Tuple[bool, bool]:
    """
    ---agentspec
    what: |
      Heuristically detects whether a docstring was generated by agentspec as YAML or narrative form.

      Returns a tuple (is_yaml, is_narrative) where:
      - is_yaml: True if the docstring contains a fenced agentspec YAML block ('---agentspec' and '---/agentspec')
      - is_narrative: True if the docstring contains agentspec narrative section headers like
        'WHAT THIS DOES:', 'WHY THIS APPROACH:', 'AGENT INSTRUCTIONS:', or deterministic sections injected by tooling
        such as 'DEPENDENCIES (from code analysis):' or 'CHANGELOG (from git history):'

      The function is conservative: it only flags narrative if at least one strong indicator is present.
    deps:
      calls:
        - any
      imports: []
    why: |
      Target only agentspec-generated content to avoid deleting user-authored docs.
    guardrails:
      - DO NOT broaden heuristics without tests; avoid false positives
      - ALWAYS check for YAML fences first
    changelog:
      - "2025-10-31: Initial implementation"
    ---/agentspec
    """
    if not doc:
        return (False, False)
    # YAML fence check
    if ('---agentspec' in doc) and ('---/agentspec' in doc):
        return (True, False)
    # Narrative markers
    markers = (
        'WHAT THIS DOES:',
        'WHY THIS APPROACH:',
        'AGENT INSTRUCTIONS:',
        'DEPENDENCIES (from code analysis):',
        'CHANGELOG (from git history):',
        'FUNCTION CODE DIFF SUMMARY (LLM-generated):',
    )
    is_narr = any(m in doc for m in markers)
    return (False, is_narr)


def strip_file(filepath: Path, mode: str, dry_run: bool = False) -> None:
    """
    ---agentspec
    what: |
      Removes agentspec-generated content from a single Python file with compile-safety per edit.

      Behavior:
      - Parses file with AST, finds functions with docstrings
      - Detects agentspec YAML vs narrative docstrings using explicit markers
      - Depending on mode ('yaml'|'docstrings'|'all'), deletes matching docstrings
      - Also removes immediate following lines containing "[AGENTSPEC_CONTEXT]" prints
      - For each deletion candidate, writes a temp file and py_compile checks before committing the change

      Inputs:
      - filepath: Path to Python file
      - mode: One of 'yaml', 'docstrings', 'all'
      - dry_run: If True, only prints actions without modifying files

      Outputs:
      - None; prints progress and performs in-place edits when not dry-run
    deps:
      calls:
        - ast.parse
        - ast.walk
        - isinstance
        - ast.get_docstring
        - _detect_agentspec_doc
        - print
        - py_compile.compile
      imports:
        - ast
        - os
        - tempfile
    why: |
      Per-edit compile checks ensure we never leave a file in a broken state. Bottom-to-top processing avoids
      line shift issues when making multiple deletions in a single file.
    guardrails:
      - DO NOT strip non-agentspec docstrings; only remove when explicit markers are found
      - ALWAYS process functions bottom-to-top to avoid line-number invalidation
      - ALWAYS use tmp file + py_compile before writing changes
      - ALWAYS delete adjacent [AGENTSPEC_CONTEXT] print line if present
    changelog:
      - "2025-10-31: Initial implementation"
    ---/agentspec
    """
    print(f"\nüßπ Processing (strip) {filepath}")
    with open(filepath, 'r', encoding='utf-8') as f:
        lines = f.readlines()

    src = ''.join(lines)
    try:
        import ast
        tree = ast.parse(src)
    except SyntaxError as e:
        print(f"  ‚ùå Syntax error in file: {e}")
        return

    # Collect function docstring spans
    targets: list[tuple[int, int, str]] = []  # (start_idx, end_idx_exclusive, func_name)
    import ast
    for node in ast.walk(tree):
        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)) and node.body:
            first_stmt = node.body[0]
            if isinstance(first_stmt, ast.Expr) and (
                (hasattr(ast, 'Constant') and isinstance(first_stmt.value, ast.Constant) and isinstance(first_stmt.value.value, str)) or
                (hasattr(ast, 'Str') and isinstance(first_stmt.value, ast.Str))
            ):
                doc_text = ast.get_docstring(node) or ''
                is_yaml, is_narr = _detect_agentspec_doc(doc_text)
                if mode == 'yaml':
                    should_delete = is_yaml
                elif mode == 'docstrings':
                    should_delete = is_narr
                else:
                    should_delete = is_yaml or is_narr
                if should_delete:
                    start = first_stmt.lineno - 1
                    end = first_stmt.end_lineno
                    if end < len(lines) and '[AGENTSPEC_CONTEXT]' in lines[end]:
                        end += 1
                    targets.append((start, end, node.name))

    if not targets:
        print("  ‚úÖ Nothing to strip in this file")
        return

    targets.sort(key=lambda t: t[0], reverse=True)

    for start_idx, end_idx, func_name in targets:
        print(f"  ‚úÇÔ∏è  Removing agentspec content in function: {func_name} (lines {start_idx+1}-{end_idx})")
        if dry_run:
            continue
        candidate = list(lines)
        del candidate[start_idx:end_idx]
        import tempfile, py_compile, os as _os
        tmp_fd, tmp_path = tempfile.mkstemp(suffix='.py')
        try:
            _os.close(tmp_fd)
            with open(tmp_path, 'w', encoding='utf-8') as tf:
                tf.writelines(candidate)
            py_compile.compile(tmp_path, doraise=True)
        except Exception as e:
            print(f"  ‚ö†Ô∏è  Syntax check failed after stripping {func_name}: {e}. Skipping this edit.")
            try:
                if _os.path.exists(tmp_path):
                    _os.remove(tmp_path)
            except Exception:
                pass
            continue
        finally:
            try:
                if _os.path.exists(tmp_path):
                    _os.remove(tmp_path)
            except Exception:
                pass
        lines = candidate
        with open(filepath, 'w', encoding='utf-8') as f:
            f.writelines(lines)
        print(f"  ‚úÖ Stripped agentspec content from {func_name}")


JS_EXTS = {".js", ".mjs", ".jsx", ".ts", ".tsx"}


def _detect_agentspec_jsdoc(block_lines: list[str]) -> tuple[bool, bool]:
    """
    ---agentspec
    what: |
      Detect whether a JSDoc block contains agentspec-generated content and whether it is YAML vs narrative.

      Returns (is_yaml, is_narrative). A block is YAML if it contains '---agentspec' or '---/agentspec'.
      A block is narrative if it contains one or more of the deterministic sections or context markers:
      - 'DEPENDENCIES (from code analysis):'
      - 'CHANGELOG (from git history):'
      - 'AGENTSPEC_CONTEXT:'
    deps:
      calls:
        - any
    guardrails:
      - DO NOT broaden heuristics without tests
      - ALWAYS check YAML fences first
    changelog:
      - "2025-11-01: Initial JS detectors"
    ---/agentspec
    """
    joined = "\n".join(block_lines)
    is_yaml = ("---agentspec" in joined) or ("---/agentspec" in joined)
    is_narr = any(
        m in joined for m in (
            "DEPENDENCIES (from code analysis):",
            "CHANGELOG (from git history):",
            "AGENTSPEC_CONTEXT:",
        )
    )
    return is_yaml, is_narr


def strip_js_file(filepath: Path, mode: str, dry_run: bool = False) -> None:
    """
    ---agentspec
    what: |
      Removes agentspec-generated JSDoc blocks from a JavaScript/TypeScript file using textual heuristics.

      Behavior:
      - Scans for '/**' ... '*/' JSDoc blocks
      - Uses _detect_agentspec_jsdoc() to classify each block as YAML vs narrative
      - Depending on mode ('yaml'|'docstrings'|'all'), deletes matching blocks
      - Also removes single following line if it matches a console.log with 'AGENTSPEC_CONTEXT'
      - Writes the file once after all removals; prints actions and respects dry_run

      Note: Syntax validation is attempted via language adapter when available; otherwise no validation is performed.
    deps:
      calls:
        - _detect_agentspec_jsdoc
      imports:
        - agentspec.langs.LanguageRegistry
    guardrails:
      - DO NOT attempt to reformat; only delete exact block spans
      - ALWAYS respect dry_run
    changelog:
      - "2025-11-01: Add JS/TS strip support"
    ---/agentspec
    """
    print(f"\nüßπ Processing (strip) {filepath}")
    try:
        text = filepath.read_text(encoding="utf-8", errors="ignore")
    except Exception as e:
        print(f"  ‚ùå Cannot read file: {e}")
        return

    lines = text.splitlines()
    n = len(lines)
    i = 0
    removed_spans: list[tuple[int, int]] = []

    while i < n:
        line = lines[i]
        if "/**" in line:
            start = i
            j = i + 1
            found_end = False
            while j < n:
                if lines[j].strip().endswith("*/"):
                    found_end = True
                    end = j
                    break
                j += 1
            if not found_end:
                i += 1
                continue
            block = lines[start : end + 1]
            is_yaml, is_narr = _detect_agentspec_jsdoc(block)
            if mode == "yaml":
                should_delete = is_yaml
            elif mode == "docstrings":
                should_delete = is_narr and not is_yaml
            else:
                should_delete = is_yaml or is_narr
            if should_delete:
                # Extend to remove one following AGENTSPEC context console.log if present
                end_plus = end + 1
                if end_plus < n and "AGENTSPEC_CONTEXT" in lines[end_plus]:
                    end = end_plus
                removed_spans.append((start, end))
                i = end + 1
                continue
            i = end + 1
        else:
            i += 1

    if not removed_spans:
        print("  ‚úÖ Nothing to strip in this file")
        return

    # Build new content by skipping removed spans
    removed_spans.sort()
    out: list[str] = []
    last = 0
    for s, e in removed_spans:
        print(f"  ‚úÇÔ∏è  Removing JSDoc lines {s+1}-{e+1}")
        out.extend(lines[last:s])
        last = e + 1
    out.extend(lines[last:])
    new_text = "\n".join(out) + ("\n" if text.endswith("\n") else "")

    if dry_run:
        return

    # Optional syntax validation via adapter
    try:
        from agentspec.langs import LanguageRegistry
        adapter = LanguageRegistry.get_by_extension(filepath.suffix.lower())
        if adapter is not None:
            adapter.validate_syntax_string(new_text)  # may raise
    except Exception:
        # Best-effort only; proceed even if validation not available
        pass

    filepath.write_text(new_text, encoding="utf-8")
    print(f"  ‚úÖ Stripped {len(removed_spans)} agentspec block(s)")


def run(target: str, mode: str = "all", dry_run: bool = False) -> int:
    """
    ---agentspec
    what: |
      Batch entry point for stripping agentspec content across Python and JavaScript/TypeScript files.

      Accepts file or directory path, collects source files across registered languages, and applies language-specific
      strip routines (AST-based for Python; JSDoc heuristic for JS/TS). Dry-run prints intended changes without modifying files.
      Returns exit code 0 on success, 1 on errors.
    deps:
      calls:
        - Path
        - collect_source_files
        - strip_file (Python)
        - strip_js_file (JavaScript/TypeScript)
        - print
      imports:
        - agentspec.utils.collect_source_files
        - pathlib.Path
    why: |
      Unifies strip behavior across languages and allows pre-clean runs before regeneration to avoid duplicate blocks.
    guardrails:
      - DO NOT require any API credentials
      - ALWAYS handle both file and directory targets
      - ALWAYS route by file extension conservatively
    changelog:
      - "2025-11-01: Extend strip to JS/TS via JSDoc heuristic and collect_source_files()"
    ---/agentspec
    """
    from agentspec.utils import collect_source_files

    path = Path(target)
    if not path.exists():
        print(f"‚ùå Error: Path does not exist: {target}")
        return 1

    files = [path] if path.is_file() else collect_source_files(path)

    for fp in files:
        try:
            ext = fp.suffix.lower()
            if ext == ".py":
                strip_file(fp, mode, dry_run=dry_run)
            elif ext in JS_EXTS:
                strip_js_file(fp, mode, dry_run=dry_run)
        except Exception as e:
            print(f"‚ùå Error processing {fp}: {e}")
    print("\n‚úÖ Done!")
    return 0
